{"ast":null,"code":"import _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport React from 'react';\nvar bugfixes = undefined;\nvar applyAnimatedValues = undefined;\nvar colorNames = [];\n\nvar requestFrame = function requestFrame(cb) {\n  return typeof window !== 'undefined' && window.requestAnimationFrame(cb);\n};\n\nvar cancelFrame = function cancelFrame(cb) {\n  return typeof window !== 'undefined' && window.cancelAnimationFrame(cb);\n};\n\nvar interpolation = undefined;\n\nvar now = function now() {\n  return Date.now();\n};\n\nvar defaultElement = undefined;\nvar createAnimatedStyle = undefined;\n\nvar injectApplyAnimatedValues = function injectApplyAnimatedValues(fn, transform) {\n  return applyAnimatedValues = {\n    fn: fn,\n    transform: transform\n  };\n};\n\nvar injectColorNames = function injectColorNames(names) {\n  return colorNames = names;\n};\n\nvar injectBugfixes = function injectBugfixes(fn) {\n  return bugfixes = fn;\n};\n\nvar injectInterpolation = function injectInterpolation(cls) {\n  return interpolation = cls;\n};\n\nvar injectFrame = function injectFrame(raf, caf) {\n  var _ref;\n\n  return _ref = [raf, caf], requestFrame = _ref[0], cancelFrame = _ref[1], _ref;\n};\n\nvar injectNow = function injectNow(nowFn) {\n  return now = nowFn;\n};\n\nvar injectDefaultElement = function injectDefaultElement(el) {\n  return defaultElement = el;\n};\n\nvar injectCreateAnimatedStyle = function injectCreateAnimatedStyle(factory) {\n  return createAnimatedStyle = factory;\n};\n\nvar Globals =\n/*#__PURE__*/\nObject.freeze({\n  get bugfixes() {\n    return bugfixes;\n  },\n\n  get applyAnimatedValues() {\n    return applyAnimatedValues;\n  },\n\n  get colorNames() {\n    return colorNames;\n  },\n\n  get requestFrame() {\n    return requestFrame;\n  },\n\n  get cancelFrame() {\n    return cancelFrame;\n  },\n\n  get interpolation() {\n    return interpolation;\n  },\n\n  get now() {\n    return now;\n  },\n\n  get defaultElement() {\n    return defaultElement;\n  },\n\n  get createAnimatedStyle() {\n    return createAnimatedStyle;\n  },\n\n  injectApplyAnimatedValues: injectApplyAnimatedValues,\n  injectColorNames: injectColorNames,\n  injectBugfixes: injectBugfixes,\n  injectInterpolation: injectInterpolation,\n  injectFrame: injectFrame,\n  injectNow: injectNow,\n  injectDefaultElement: injectDefaultElement,\n  injectCreateAnimatedStyle: injectCreateAnimatedStyle\n});\n\nvar Animated =\n/*#__PURE__*/\nfunction () {\n  function Animated() {}\n\n  var _proto = Animated.prototype;\n\n  _proto.attach = function attach() {};\n\n  _proto.detach = function detach() {};\n\n  _proto.getValue = function getValue() {};\n\n  _proto.getAnimatedValue = function getAnimatedValue() {\n    return this.getValue();\n  };\n\n  _proto.addChild = function addChild(child) {};\n\n  _proto.removeChild = function removeChild(child) {};\n\n  _proto.getChildren = function getChildren() {\n    return [];\n  };\n\n  return Animated;\n}();\n\nvar getValues = function getValues(object) {\n  return Object.keys(object).map(function (k) {\n    return object[k];\n  });\n};\n\nvar AnimatedWithChildren =\n/*#__PURE__*/\nfunction (_Animated) {\n  _inheritsLoose(AnimatedWithChildren, _Animated);\n\n  function AnimatedWithChildren() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _Animated.call.apply(_Animated, [this].concat(args)) || this;\n    _this.children = [];\n\n    _this.getChildren = function () {\n      return _this.children;\n    };\n\n    _this.getPayload = function (index) {\n      if (index === void 0) {\n        index = undefined;\n      }\n\n      return index !== void 0 && _this.payload ? _this.payload[index] : _this.payload || _assertThisInitialized(_assertThisInitialized(_this));\n    };\n\n    return _this;\n  }\n\n  var _proto = AnimatedWithChildren.prototype;\n\n  _proto.addChild = function addChild(child) {\n    if (this.children.length === 0) this.attach();\n    this.children.push(child);\n  };\n\n  _proto.removeChild = function removeChild(child) {\n    var index = this.children.indexOf(child);\n    this.children.splice(index, 1);\n    if (this.children.length === 0) this.detach();\n  };\n\n  return AnimatedWithChildren;\n}(Animated);\n\nvar AnimatedArrayWithChildren =\n/*#__PURE__*/\nfunction (_AnimatedWithChildren) {\n  _inheritsLoose(AnimatedArrayWithChildren, _AnimatedWithChildren);\n\n  function AnimatedArrayWithChildren() {\n    var _this2;\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    _this2 = _AnimatedWithChildren.call.apply(_AnimatedWithChildren, [this].concat(args)) || this;\n    _this2.payload = [];\n\n    _this2.getAnimatedValue = function () {\n      return _this2.getValue();\n    };\n\n    _this2.attach = function () {\n      return _this2.payload.forEach(function (p) {\n        return p instanceof Animated && p.addChild(_assertThisInitialized(_assertThisInitialized(_this2)));\n      });\n    };\n\n    _this2.detach = function () {\n      return _this2.payload.forEach(function (p) {\n        return p instanceof Animated && p.removeChild(_assertThisInitialized(_assertThisInitialized(_this2)));\n      });\n    };\n\n    return _this2;\n  }\n\n  return AnimatedArrayWithChildren;\n}(AnimatedWithChildren);\n\nvar AnimatedObjectWithChildren =\n/*#__PURE__*/\nfunction (_AnimatedWithChildren2) {\n  _inheritsLoose(AnimatedObjectWithChildren, _AnimatedWithChildren2);\n\n  function AnimatedObjectWithChildren() {\n    var _this3;\n\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    _this3 = _AnimatedWithChildren2.call.apply(_AnimatedWithChildren2, [this].concat(args)) || this;\n    _this3.payload = {};\n\n    _this3.getAnimatedValue = function () {\n      return _this3.getValue(true);\n    };\n\n    _this3.attach = function () {\n      return getValues(_this3.payload).forEach(function (s) {\n        return s instanceof Animated && s.addChild(_assertThisInitialized(_assertThisInitialized(_this3)));\n      });\n    };\n\n    _this3.detach = function () {\n      return getValues(_this3.payload).forEach(function (s) {\n        return s instanceof Animated && s.removeChild(_assertThisInitialized(_assertThisInitialized(_this3)));\n      });\n    };\n\n    return _this3;\n  }\n\n  var _proto2 = AnimatedObjectWithChildren.prototype;\n\n  _proto2.getValue = function getValue(animated) {\n    if (animated === void 0) {\n      animated = false;\n    }\n\n    var payload = {};\n\n    for (var key in this.payload) {\n      var value = this.payload[key];\n      if (animated && !(value instanceof Animated)) continue;\n      payload[key] = value instanceof Animated ? value[animated ? 'getAnimatedValue' : 'getValue']() : value;\n    }\n\n    return payload;\n  };\n\n  return AnimatedObjectWithChildren;\n}(AnimatedWithChildren);\n\nvar Interpolation$1 =\n/*#__PURE__*/\nfunction () {\n  function Interpolation() {} // Default config = config, args\n  // Short config   = range, output, extrapolate\n\n\n  Interpolation.create = function create(config, output, extra) {\n    if (typeof config === 'function') return config;else if (interpolation && config.output && typeof config.output[0] === 'string') return interpolation(config);else if (Array.isArray(config)) return Interpolation.create({\n      range: config,\n      output: output,\n      extrapolate: extra || 'extend'\n    });\n    var outputRange = config.output;\n    var inputRange = config.range || [0, 1];\n\n    var easing = config.easing || function (t) {\n      return t;\n    };\n\n    var extrapolateLeft = 'extend';\n    var map = config.map;\n    if (config.extrapolateLeft !== undefined) extrapolateLeft = config.extrapolateLeft;else if (config.extrapolate !== undefined) extrapolateLeft = config.extrapolate;\n    var extrapolateRight = 'extend';\n    if (config.extrapolateRight !== undefined) extrapolateRight = config.extrapolateRight;else if (config.extrapolate !== undefined) extrapolateRight = config.extrapolate;\n    return function (input) {\n      var range = findRange(input, inputRange);\n      return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight, map);\n    };\n  };\n\n  return Interpolation;\n}();\n\nfunction interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {\n  var result = map ? map(input) : input; // Extrapolate\n\n  if (result < inputMin) {\n    if (extrapolateLeft === 'identity') return result;else if (extrapolateLeft === 'clamp') result = inputMin;\n  }\n\n  if (result > inputMax) {\n    if (extrapolateRight === 'identity') return result;else if (extrapolateRight === 'clamp') result = inputMax;\n  }\n\n  if (outputMin === outputMax) return outputMin;\n  if (inputMin === inputMax) return input <= inputMin ? outputMin : outputMax; // Input Range\n\n  if (inputMin === -Infinity) result = -result;else if (inputMax === Infinity) result = result - inputMin;else result = (result - inputMin) / (inputMax - inputMin); // Easing\n\n  result = easing(result); // Output Range\n\n  if (outputMin === -Infinity) result = -result;else if (outputMax === Infinity) result = result + outputMin;else result = result * (outputMax - outputMin) + outputMin;\n  return result;\n}\n\nfunction findRange(input, inputRange) {\n  for (var i = 1; i < inputRange.length - 1; ++i) {\n    if (inputRange[i] >= input) break;\n  }\n\n  return i - 1;\n}\n\nvar AnimatedInterpolation =\n/*#__PURE__*/\nfunction (_AnimatedArrayWithChi) {\n  _inheritsLoose(AnimatedInterpolation, _AnimatedArrayWithChi);\n\n  function AnimatedInterpolation(parents, _config, _arg) {\n    var _this;\n\n    _this = _AnimatedArrayWithChi.call(this) || this;\n\n    _this.getValue = function () {\n      var _this2;\n\n      return (_this2 = _this).calc.apply(_this2, _this.payload.map(function (value) {\n        return value.getValue();\n      }));\n    };\n\n    _this.updateConfig = function (config, arg) {\n      return _this.calc = Interpolation$1.create(config, arg);\n    };\n\n    _this.interpolate = function (config, arg) {\n      return new AnimatedInterpolation(_assertThisInitialized(_assertThisInitialized(_this)), config, arg);\n    };\n\n    _this.payload = // AnimatedArrays should unfold, except AnimatedInterpolation which is taken as is\n    parents instanceof AnimatedArrayWithChildren && !parents.updateConfig ? parents.payload : Array.isArray(parents) ? parents : [parents];\n    _this.calc = Interpolation$1.create(_config, _arg);\n    return _this;\n  }\n\n  return AnimatedInterpolation;\n}(AnimatedArrayWithChildren);\n\nvar interpolate$1 = function interpolate(parents, config, arg) {\n  return parents && new AnimatedInterpolation(parents, config, arg);\n};\n/**\n * Animated works by building a directed acyclic graph of dependencies\n * transparently when you render your Animated components.\n *\n *               new Animated.Value(0)\n *     .interpolate()        .interpolate()    new Animated.Value(1)\n *         opacity               translateY      scale\n *          style                         transform\n *         View#234                         style\n *                                         View#123\n *\n * A) Top Down phase\n * When an Animated.Value is updated, we recursively go down through this\n * graph in order to find leaf nodes: the views that we flag as needing\n * an update.\n *\n * B) Bottom Up phase\n * When a view is flagged as needing an update, we recursively go back up\n * in order to build the new value that it needs. The reason why we need\n * this two-phases process is to deal with composite props such as\n * transform which can receive values from multiple parents.\n */\n\n\nfunction findAnimatedStyles(node, styles) {\n  if (typeof node.update === 'function') styles.add(node);else node.getChildren().forEach(function (child) {\n    return findAnimatedStyles(child, styles);\n  });\n}\n/**\n * Standard value for driving animations.  One `Animated.Value` can drive\n * multiple properties in a synchronized fashion, but can only be driven by one\n * mechanism at a time.  Using a new mechanism (e.g. starting a new animation,\n * or calling `setValue`) will stop any previous ones.\n */\n\n\nvar AnimatedValue =\n/*#__PURE__*/\nfunction (_AnimatedWithChildren) {\n  _inheritsLoose(AnimatedValue, _AnimatedWithChildren);\n\n  function AnimatedValue(_value) {\n    var _this;\n\n    _this = _AnimatedWithChildren.call(this) || this;\n\n    _this.setValue = function (value, flush) {\n      if (flush === void 0) {\n        flush = true;\n      }\n\n      _this.value = value;\n      if (flush) _this.flush();\n    };\n\n    _this.getValue = function () {\n      return _this.value;\n    };\n\n    _this.updateStyles = function () {\n      return findAnimatedStyles(_assertThisInitialized(_assertThisInitialized(_this)), _this.animatedStyles);\n    };\n\n    _this.updateValue = function (value) {\n      return _this.flush(_this.value = value);\n    };\n\n    _this.interpolate = function (config, arg) {\n      return new AnimatedInterpolation(_assertThisInitialized(_assertThisInitialized(_this)), config, arg);\n    };\n\n    _this.value = _value;\n    _this.animatedStyles = new Set();\n    _this.done = false;\n    _this.startPosition = _value;\n    _this.lastPosition = _value;\n    _this.lastVelocity = undefined;\n    _this.lastTime = undefined;\n    _this.controller = undefined;\n    return _this;\n  }\n\n  var _proto = AnimatedValue.prototype;\n\n  _proto.flush = function flush() {\n    if (this.animatedStyles.size === 0) this.updateStyles();\n    this.animatedStyles.forEach(function (animatedStyle) {\n      return animatedStyle.update();\n    });\n  };\n\n  _proto.prepare = function prepare(controller) {\n    // Values stay loyal to their original controller, this is also a way to\n    // detect trailing values originating from a foreign controller\n    if (this.controller === undefined) this.controller = controller;\n\n    if (this.controller === controller) {\n      this.startPosition = this.value;\n      this.lastPosition = this.value;\n      this.lastVelocity = controller.isActive ? this.lastVelocity : undefined;\n      this.lastTime = controller.isActive ? this.lastTime : undefined;\n      this.done = false;\n      this.animatedStyles.clear();\n    }\n  };\n\n  return AnimatedValue;\n}(AnimatedWithChildren);\n\nvar AnimatedArray =\n/*#__PURE__*/\nfunction (_AnimatedArrayWithChi) {\n  _inheritsLoose(AnimatedArray, _AnimatedArrayWithChi);\n\n  function AnimatedArray(array) {\n    var _this;\n\n    _this = _AnimatedArrayWithChi.call(this) || this;\n\n    _this.setValue = function (value, flush) {\n      if (flush === void 0) {\n        flush = true;\n      }\n\n      if (Array.isArray(value)) {\n        if (value.length === _this.payload.length) value.forEach(function (v, i) {\n          return _this.payload[i].setValue(v, flush);\n        });\n      } else _this.payload.forEach(function (v, i) {\n        return _this.payload[i].setValue(value, flush);\n      });\n    };\n\n    _this.getValue = function () {\n      return _this.payload.map(function (v) {\n        return v.getValue();\n      });\n    };\n\n    _this.interpolate = function (config, arg) {\n      return new AnimatedInterpolation(_assertThisInitialized(_assertThisInitialized(_this)), config, arg);\n    };\n\n    _this.payload = array.map(function (n) {\n      return new AnimatedValue(n);\n    });\n    return _this;\n  }\n\n  return AnimatedArray;\n}(AnimatedArrayWithChildren);\n\nvar active = false;\nvar controllers = new Set();\n\nvar frameLoop = function frameLoop() {\n  var time = now();\n\n  for (var _iterator = controllers, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var controller = _ref;\n    var isDone = true;\n    var noChange = true;\n\n    for (var configIdx = 0; configIdx < controller.configs.length; configIdx++) {\n      var config = controller.configs[configIdx];\n      var endOfAnimation = void 0,\n          lastTime = void 0;\n\n      for (var valIdx = 0; valIdx < config.animatedValues.length; valIdx++) {\n        var animation = config.animatedValues[valIdx]; // If an animation is done, skip, until all of them conclude\n\n        if (animation.done) continue;\n        var from = config.fromValues[valIdx];\n        var to = config.toValues[valIdx];\n        var position = animation.lastPosition;\n        var isAnimated = to instanceof Animated;\n\n        var _velocity = Array.isArray(config.initialVelocity) ? config.initialVelocity[valIdx] : config.initialVelocity;\n\n        if (isAnimated) to = to.getValue(); // Conclude animation if it's either immediate, or from-values match end-state\n\n        if (config.immediate || !isAnimated && !config.decay && from === to) {\n          animation.updateValue(to);\n          animation.done = true;\n          continue;\n        } // Doing delay here instead of setTimeout is one async worry less\n\n\n        if (config.delay && time - controller.startTime < config.delay) {\n          isDone = false;\n          continue;\n        } // Flag change\n\n\n        noChange = false; // Break animation when string values are involved\n\n        if (typeof from === 'string' || typeof to === 'string') {\n          animation.updateValue(to);\n          animation.done = true;\n          continue;\n        }\n\n        if (config.duration !== void 0) {\n          /** Duration easing */\n          position = from + config.easing((time - controller.startTime - config.delay) / config.duration) * (to - from);\n          endOfAnimation = time >= controller.startTime + config.delay + config.duration;\n        } else if (config.decay) {\n          /** Decay easing */\n          position = from + _velocity / (1 - 0.998) * (1 - Math.exp(-(1 - 0.998) * (time - controller.startTime)));\n          endOfAnimation = Math.abs(animation.lastPosition - position) < 0.1;\n          if (endOfAnimation) to = position;\n        } else {\n          /** Spring easing */\n          lastTime = animation.lastTime !== void 0 ? animation.lastTime : time;\n          _velocity = animation.lastVelocity !== void 0 ? animation.lastVelocity : config.initialVelocity; // If we lost a lot of frames just jump to the end.\n\n          if (time > lastTime + 64) lastTime = time; // http://gafferongames.com/game-physics/fix-your-timestep/\n\n          var numSteps = Math.floor(time - lastTime);\n\n          for (var i = 0; i < numSteps; ++i) {\n            var force = -config.tension * (position - to);\n            var damping = -config.friction * _velocity;\n            var acceleration = (force + damping) / config.mass;\n            _velocity = _velocity + acceleration * 1 / 1000;\n            position = position + _velocity * 1 / 1000;\n          } // Conditions for stopping the spring animation\n\n\n          var isOvershooting = config.clamp && config.tension !== 0 ? from < to ? position > to : position < to : false;\n          var isVelocity = Math.abs(_velocity) <= config.precision;\n          var isDisplacement = config.tension !== 0 ? Math.abs(to - position) <= config.precision : true;\n          endOfAnimation = isOvershooting || isVelocity && isDisplacement;\n          animation.lastVelocity = _velocity;\n          animation.lastTime = time;\n        } // Trails aren't done until their parents conclude\n\n\n        if (isAnimated && !config.toValues[valIdx].done) endOfAnimation = false;\n\n        if (endOfAnimation) {\n          // Ensure that we end up with a round value\n          if (animation.value !== to) position = to;\n          animation.done = true;\n        } else isDone = false;\n\n        animation.updateValue(position);\n        animation.lastPosition = position;\n      } // Keep track of updated values only when necessary\n\n\n      if (controller.props.onFrame || !controller.props.native) controller.animatedProps[config.name] = config.interpolation.getValue();\n    } // Update callbacks in the end of the frame\n\n\n    if (controller.props.onFrame || !controller.props.native) {\n      if (!controller.props.native && controller.onUpdate) controller.onUpdate();\n      if (controller.props.onFrame) controller.props.onFrame(controller.animatedProps);\n    } // Either call onEnd or next frame\n\n\n    if (isDone) {\n      controllers.delete(controller);\n      controller.debouncedOnEnd({\n        finished: true,\n        noChange: noChange\n      });\n    }\n  } // Loop over as long as there are controllers ...\n\n\n  if (controllers.size) requestFrame(frameLoop);else active = false;\n};\n\nvar addController = function addController(controller) {\n  if (!controllers.has(controller)) {\n    controllers.add(controller);\n    if (!active) requestFrame(frameLoop);\n    active = true;\n  }\n};\n\nvar removeController = function removeController(controller) {\n  if (controllers.has(controller)) {\n    controllers.delete(controller);\n  }\n};\n\nfunction withDefault(value, defaultValue) {\n  return value === undefined || value === null ? defaultValue : value;\n}\n\nfunction toArray(a) {\n  return a !== void 0 ? Array.isArray(a) ? a : [a] : [];\n}\n\nfunction shallowEqual(a, b) {\n  if (typeof a !== typeof b) return false;\n  if (typeof a === 'string' || typeof a === 'number') return a === b;\n  var i;\n\n  for (i in a) {\n    if (!(i in b)) return false;\n  }\n\n  for (i in b) {\n    if (a[i] !== b[i]) return false;\n  }\n\n  return i === void 0 ? a === b : true;\n}\n\nfunction callProp(obj) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return typeof obj === 'function' ? obj.apply(void 0, args) : obj;\n}\n\nfunction getValues$1(object) {\n  return Object.keys(object).map(function (k) {\n    return object[k];\n  });\n}\n\nfunction getForwardProps(props) {\n  var to = props.to,\n      from = props.from,\n      config = props.config,\n      native = props.native,\n      onStart = props.onStart,\n      onRest = props.onRest,\n      onFrame = props.onFrame,\n      children = props.children,\n      reset = props.reset,\n      reverse = props.reverse,\n      force = props.force,\n      immediate = props.immediate,\n      impl = props.impl,\n      inject = props.inject,\n      delay = props.delay,\n      attach = props.attach,\n      destroyed = props.destroyed,\n      interpolateTo = props.interpolateTo,\n      autoStart = props.autoStart,\n      ref = props.ref,\n      forward = _objectWithoutPropertiesLoose(props, [\"to\", \"from\", \"config\", \"native\", \"onStart\", \"onRest\", \"onFrame\", \"children\", \"reset\", \"reverse\", \"force\", \"immediate\", \"impl\", \"inject\", \"delay\", \"attach\", \"destroyed\", \"interpolateTo\", \"autoStart\", \"ref\"]);\n\n  return forward;\n}\n\nfunction interpolateTo(props) {\n  var forward = getForwardProps(props);\n  var rest = Object.keys(props).reduce(function (a, k) {\n    var _extends2;\n\n    return forward[k] !== void 0 ? a : _extends({}, a, (_extends2 = {}, _extends2[k] = props[k], _extends2));\n  }, {});\n  return _extends({\n    to: forward\n  }, rest);\n}\n\nfunction convertToAnimatedValue(acc, _ref) {\n  var _extends3;\n\n  var name = _ref[0],\n      value = _ref[1];\n  return _extends({}, acc, (_extends3 = {}, _extends3[name] = new (Array.isArray(value) ? AnimatedArray : AnimatedValue)(value), _extends3));\n}\n\nfunction convertValues(props) {\n  var from = props.from,\n      to = props.to,\n      native = props.native;\n  var allProps = Object.entries(_extends({}, from, to));\n  return native ? allProps.reduce(convertToAnimatedValue, {}) : _extends({}, from, to);\n}\n\nfunction handleRef(ref, forward) {\n  if (forward) {\n    // If it's a function, assume it's a ref callback\n    if (typeof forward === 'function') forward(ref);else if (typeof forward === 'object') {\n      // If it's an object and has a 'current' property, assume it's a ref object\n      forward.current = ref;\n    }\n  }\n\n  return ref;\n}\n\nvar Controller =\n/*#__PURE__*/\nfunction () {\n  function Controller(props, config) {\n    var _this = this;\n\n    if (config === void 0) {\n      config = {\n        native: true,\n        interpolateTo: true,\n        autoStart: true\n      };\n    }\n\n    this.getValues = function () {\n      return _this.props.native ? _this.interpolations : _this.animatedProps;\n    };\n\n    this.dependents = new Set();\n    this.isActive = false;\n    this.hasChanged = false;\n    this.props = {};\n    this.merged = {};\n    this.animations = {};\n    this.interpolations = {};\n    this.animatedProps = {};\n    this.configs = [];\n    this.frame = undefined;\n    this.startTime = undefined;\n    this.lastTime = undefined;\n    this.update(_extends({}, props, config));\n  }\n\n  var _proto = Controller.prototype;\n\n  _proto.update = function update(props) {\n    var _this2 = this;\n\n    this.props = _extends({}, this.props, props);\n\n    var _ref = this.props.interpolateTo ? interpolateTo(this.props) : this.props,\n        _ref$from = _ref.from,\n        from = _ref$from === void 0 ? {} : _ref$from,\n        _ref$to = _ref.to,\n        to = _ref$to === void 0 ? {} : _ref$to,\n        _ref$config = _ref.config,\n        config = _ref$config === void 0 ? {} : _ref$config,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === void 0 ? 0 : _ref$delay,\n        reverse = _ref.reverse,\n        attach = _ref.attach,\n        reset = _ref.reset,\n        immediate = _ref.immediate,\n        autoStart = _ref.autoStart,\n        ref = _ref.ref; // Reverse values when requested\n\n\n    if (reverse) {\n      var _ref2 = [to, from];\n      from = _ref2[0];\n      to = _ref2[1];\n    }\n\n    this.hasChanged = false; // Attachment handling, trailed springs can \"attach\" themselves to a previous spring\n\n    var target = attach && attach(this); // Reset merged props when necessary\n\n    var extra = reset ? {} : this.merged; // This will collect all props that were ever set\n\n    this.merged = _extends({}, from, extra, to); // Reduces input { name: value } pairs into animated values\n\n    this.animations = Object.entries(this.merged).reduce(function (acc, _ref3, i) {\n      var name = _ref3[0],\n          value = _ref3[1]; // Issue cached entries, except on reset\n\n      var entry = !reset && acc[name] || {}; // Figure out what the value is supposed to be\n\n      var isNumber = typeof value === 'number';\n      var isString = typeof value === 'string' && !value.startsWith('#') && !/\\d/.test(value) && !colorNames[value];\n      var isArray = !isNumber && !isString && Array.isArray(value);\n      var fromValue = from[name] !== undefined ? from[name] : value;\n      var toValue = isNumber || isArray ? value : isString ? value : 1;\n      var toConfig = callProp(config, name);\n      if (target) toValue = target.animations[name].parent; // Detect changes, animated values will be checked in the raf-loop\n\n      if (toConfig.decay !== void 0 || !shallowEqual(entry.changes, value)) {\n        var _extends2;\n\n        _this2.hasChanged = true;\n        var parent, interpolation$$1;\n        if (isNumber || isString) parent = interpolation$$1 = entry.parent || new AnimatedValue(fromValue);else if (isArray) parent = interpolation$$1 = entry.parent || new AnimatedArray(fromValue);else {\n          var prev = entry.interpolation && entry.interpolation.calc(entry.parent.value);\n\n          if (entry.parent) {\n            parent = entry.parent;\n            parent.setValue(0, false);\n          } else parent = new AnimatedValue(0);\n\n          var range = {\n            output: [prev !== void 0 ? prev : fromValue, value]\n          };\n\n          if (entry.interpolation) {\n            interpolation$$1 = entry.interpolation;\n            entry.interpolation.updateConfig(range);\n          } else interpolation$$1 = parent.interpolate(range);\n        } // Set immediate values\n\n        if (callProp(immediate, name)) parent.setValue(value, false); // Reset animated values\n\n        var animatedValues = toArray(parent.getPayload());\n        animatedValues.forEach(function (value) {\n          return value.prepare(_this2);\n        });\n        return _extends({}, acc, (_extends2 = {}, _extends2[name] = _extends({}, entry, {\n          name: name,\n          parent: parent,\n          interpolation: interpolation$$1,\n          animatedValues: animatedValues,\n          changes: value,\n          fromValues: toArray(parent.getValue()),\n          toValues: toArray(target ? toValue.getPayload() : toValue),\n          immediate: callProp(immediate, name),\n          delay: withDefault(toConfig.delay, delay || 0),\n          initialVelocity: withDefault(toConfig.velocity, 0),\n          clamp: withDefault(toConfig.clamp, false),\n          precision: withDefault(toConfig.precision, 0.01),\n          tension: withDefault(toConfig.tension, 170),\n          friction: withDefault(toConfig.friction, 26),\n          mass: withDefault(toConfig.mass, 1),\n          duration: toConfig.duration,\n          easing: withDefault(toConfig.easing, function (t) {\n            return t;\n          }),\n          decay: toConfig.decay\n        }), _extends2));\n      } else return acc;\n    }, this.animations);\n\n    if (this.hasChanged) {\n      this.configs = getValues$1(this.animations);\n      this.animatedProps = {};\n      this.interpolations = {};\n\n      for (var key in this.animations) {\n        this.interpolations[key] = this.animations[key].interpolation;\n        this.animatedProps[key] = this.animations[key].interpolation.getValue();\n      }\n    } // TODO: clean up ref in controller\n\n\n    for (var _len = arguments.length, start = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      start[_key - 1] = arguments[_key];\n    }\n\n    if (!ref && (autoStart || start.length)) this.start.apply(this, start);\n    var onEnd = start[0],\n        onUpdate = start[1];\n    this.onEnd = typeof onEnd === 'function' && onEnd;\n    this.onUpdate = onUpdate;\n    return this.getValues();\n  };\n\n  _proto.start = function start(onEnd, onUpdate) {\n    var _this3 = this;\n\n    this.startTime = now();\n    if (this.isActive) this.stop();\n    this.isActive = true;\n    this.onEnd = typeof onEnd === 'function' && onEnd;\n    this.onUpdate = onUpdate;\n    if (this.props.onStart) this.props.onStart();\n    addController(this);\n    return new Promise(function (res) {\n      return _this3.resolve = res;\n    });\n  };\n\n  _proto.stop = function stop(finished) {\n    if (finished === void 0) {\n      finished = false;\n    } // Reset collected changes since the animation has been stopped cold turkey\n\n\n    if (finished) getValues$1(this.animations).forEach(function (a) {\n      return a.changes = undefined;\n    });\n    this.debouncedOnEnd({\n      finished: finished\n    });\n  };\n\n  _proto.destroy = function destroy() {\n    removeController(this);\n    this.props = {};\n    this.merged = {};\n    this.animations = {};\n    this.interpolations = {};\n    this.animatedProps = {};\n    this.configs = [];\n  };\n\n  _proto.debouncedOnEnd = function debouncedOnEnd(result) {\n    removeController(this);\n    this.isActive = false;\n    var onEnd = this.onEnd;\n    this.onEnd = null;\n    if (onEnd) onEnd(result);\n    if (this.resolve) this.resolve();\n    this.resolve = null;\n  };\n\n  return Controller;\n}();\n\nvar AnimatedProps =\n/*#__PURE__*/\nfunction (_AnimatedObjectWithCh) {\n  _inheritsLoose(AnimatedProps, _AnimatedObjectWithCh);\n\n  function AnimatedProps(props, callback) {\n    var _this;\n\n    _this = _AnimatedObjectWithCh.call(this) || this;\n    if (props.style) props = _extends({}, props, {\n      style: createAnimatedStyle(props.style)\n    });\n    _this.payload = props;\n    _this.update = callback;\n\n    _this.attach();\n\n    return _this;\n  }\n\n  return AnimatedProps;\n}(AnimatedObjectWithChildren);\n\nfunction createAnimatedComponent(Component) {\n  var AnimatedComponent =\n  /*#__PURE__*/\n  function (_React$Component) {\n    _inheritsLoose(AnimatedComponent, _React$Component);\n\n    function AnimatedComponent(props) {\n      var _this;\n\n      _this = _React$Component.call(this) || this;\n\n      _this.callback = function () {\n        if (_this.node) {\n          var didUpdate = applyAnimatedValues.fn(_this.node, _this.propsAnimated.getAnimatedValue(), _assertThisInitialized(_assertThisInitialized(_this)));\n          if (didUpdate === false) _this.forceUpdate();\n        }\n      };\n\n      _this.attachProps(props);\n\n      return _this;\n    }\n\n    var _proto = AnimatedComponent.prototype;\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      this.propsAnimated && this.propsAnimated.detach();\n    };\n\n    _proto.setNativeProps = function setNativeProps(props) {\n      var didUpdate = applyAnimatedValues.fn(this.node, props, this);\n      if (didUpdate === false) this.forceUpdate();\n    } // The system is best designed when setNativeProps is implemented. It is\n    // able to avoid re-rendering and directly set the attributes that\n    // changed. However, setNativeProps can only be implemented on leaf\n    // native components. If you want to animate a composite component, you\n    // need to re-render it. In this case, we have a fallback that uses\n    // forceUpdate.\n    ;\n\n    _proto.attachProps = function attachProps(_ref) {\n      var forwardRef = _ref.forwardRef,\n          nextProps = _objectWithoutPropertiesLoose(_ref, [\"forwardRef\"]);\n\n      var oldPropsAnimated = this.propsAnimated;\n      this.propsAnimated = new AnimatedProps(nextProps, this.callback); // When you call detach, it removes the element from the parent list\n      // of children. If it goes to 0, then the parent also detaches itself\n      // and so on.\n      // An optimization is to attach the new elements and THEN detach the old\n      // ones instead of detaching and THEN attaching.\n      // This way the intermediate state isn't to go to 0 and trigger\n      // this expensive recursive detaching to then re-attach everything on\n      // the very next operation.\n\n      oldPropsAnimated && oldPropsAnimated.detach();\n    };\n\n    _proto.shouldComponentUpdate = function shouldComponentUpdate(props) {\n      var style = props.style,\n          nextProps = _objectWithoutPropertiesLoose(props, [\"style\"]);\n\n      var _this$props = this.props,\n          currentStyle = _this$props.style,\n          currentProps = _objectWithoutPropertiesLoose(_this$props, [\"style\"]);\n\n      if (!shallowEqual(currentProps, nextProps) || !shallowEqual(currentStyle, style)) {\n        this.attachProps(props);\n        return true;\n      }\n\n      return false;\n    };\n\n    _proto.render = function render() {\n      var _this2 = this;\n\n      var _this$propsAnimated$g = this.propsAnimated.getValue(),\n          scrollTop = _this$propsAnimated$g.scrollTop,\n          scrollLeft = _this$propsAnimated$g.scrollLeft,\n          animatedProps = _objectWithoutPropertiesLoose(_this$propsAnimated$g, [\"scrollTop\", \"scrollLeft\"]);\n\n      return React.createElement(Component, _extends({}, animatedProps, {\n        ref: function ref(node) {\n          return _this2.node = handleRef(node, _this2.props.forwardRef);\n        }\n      }));\n    };\n\n    return AnimatedComponent;\n  }(React.Component);\n\n  return React.forwardRef(function (props, ref) {\n    return React.createElement(AnimatedComponent, _extends({}, props, {\n      forwardRef: ref\n    }));\n  });\n}\n\nvar config = {\n  default: {\n    tension: 170,\n    friction: 26\n  },\n  gentle: {\n    tension: 120,\n    friction: 14\n  },\n  wobbly: {\n    tension: 180,\n    friction: 12\n  },\n  stiff: {\n    tension: 210,\n    friction: 20\n  },\n  slow: {\n    tension: 280,\n    friction: 60\n  },\n  molasses: {\n    tension: 280,\n    friction: 120\n  }\n};\n\nvar Spring =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(Spring, _React$Component);\n\n  function Spring() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.state = {\n      lastProps: {\n        from: {},\n        to: {}\n      },\n      propsChanged: false,\n      internal: false\n    };\n    _this.controller = new Controller(null, null);\n    _this.didUpdate = false;\n    _this.didInject = false;\n    _this.finished = true;\n\n    _this.start = function () {\n      _this.finished = false;\n      var wasMounted = _this.mounted;\n\n      _this.controller.start(function (props) {\n        return _this.finish(_extends({}, props, {\n          wasMounted: wasMounted\n        }));\n      }, _this.update);\n    };\n\n    _this.stop = function () {\n      return _this.controller.stop(true);\n    };\n\n    _this.update = function () {\n      return _this.mounted && _this.setState({\n        internal: true\n      });\n    };\n\n    _this.finish = function (_ref) {\n      var finished = _ref.finished,\n          noChange = _ref.noChange,\n          wasMounted = _ref.wasMounted;\n      _this.finished = true;\n\n      if (_this.mounted && finished) {\n        // Only call onRest if either we *were* mounted, or when there were changes\n        if (_this.props.onRest && (wasMounted || !noChange)) _this.props.onRest(_this.controller.merged); // Restore end-state\n\n        if (_this.mounted && _this.didInject) {\n          _this.afterInject = convertValues(_this.props);\n\n          _this.setState({\n            internal: true\n          });\n        } // If we have an inject or values to apply after the animation we ping here\n\n\n        if (_this.mounted && (_this.didInject || _this.props.after)) _this.setState({\n          internal: true\n        });\n        _this.didInject = false;\n      }\n    };\n\n    return _this;\n  }\n\n  var _proto = Spring.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    // componentDidUpdate isn't called on mount, we call it here to start animating\n    this.componentDidUpdate();\n    this.mounted = true;\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    // Stop all ongoing animtions\n    this.mounted = false;\n    this.stop();\n  };\n\n  Spring.getDerivedStateFromProps = function getDerivedStateFromProps(props, _ref2) {\n    var internal = _ref2.internal,\n        lastProps = _ref2.lastProps; // The following is a test against props that could alter the animation\n\n    var from = props.from,\n        to = props.to,\n        reset = props.reset,\n        force = props.force;\n    var propsChanged = !shallowEqual(to, lastProps.to) || !shallowEqual(from, lastProps.from) || reset && !internal || force && !internal;\n    return {\n      propsChanged: propsChanged,\n      lastProps: props,\n      internal: false\n    };\n  };\n\n  _proto.render = function render() {\n    var _this2 = this;\n\n    var children = this.props.children;\n    var propsChanged = this.state.propsChanged; // Inject phase -----------------------------------------------------------\n    // Handle injected frames, for instance targets/web/fix-auto\n    // An inject will return an intermediary React node which measures itself out\n    // .. and returns a callback when the values sought after are ready, usually \"auto\".\n\n    if (this.props.inject && propsChanged && !this.injectProps) {\n      var frame = this.props.inject(this.props, function (injectProps) {\n        // The inject frame has rendered, now let's update animations...\n        _this2.injectProps = injectProps;\n\n        _this2.setState({\n          internal: true\n        });\n      }); // Render out injected frame\n\n      if (frame) return frame;\n    } // Update phase -----------------------------------------------------------\n\n\n    if (this.injectProps || propsChanged) {\n      // We can potentially cause setState, but we're inside render, the flag prevents that\n      this.didInject = false; // Update animations, this turns from/to props into AnimatedValues\n      // An update can occur on injected props, or when own-props have changed.\n\n      if (this.injectProps) {\n        this.controller.update(this.injectProps); // didInject is needed, because there will be a 3rd stage, where the original values\n        // .. will be restored after the animation is finished. When someone animates towards\n        // .. \"auto\", the end-result should be \"auto\", not \"1999px\", which would block nested\n        // .. height/width changes.\n\n        this.didInject = true;\n      } else if (propsChanged) this.controller.update(this.props); // Flag an update that occured, componentDidUpdate will start the animation later on\n\n\n      this.didUpdate = true;\n      this.afterInject = undefined;\n      this.injectProps = undefined;\n    } // Render phase -----------------------------------------------------------\n    // Render out raw values or AnimatedValues depending on \"native\"\n\n\n    var values = _extends({}, this.controller.getValues(), this.afterInject);\n\n    if (this.finished) values = _extends({}, values, this.props.after);\n    return Object.keys(values).length ? children(values) : null;\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate() {\n    // The animation has to start *after* render, since at that point the scene\n    // .. graph should be established, so we do it here. Unfortunatelly, non-native\n    // .. animations as well as \"auto\"-injects call forceUpdate, so it's causing a loop.\n    // .. didUpdate prevents that as it gets set only on prop changes.\n    if (this.didUpdate) this.start();\n    this.didUpdate = false;\n  };\n\n  return Spring;\n}(React.Component);\n\nSpring.defaultProps = {\n  from: {},\n  to: {},\n  config: config.default,\n  native: false,\n  immediate: false,\n  reset: false,\n  force: false,\n  inject: bugfixes\n};\n\nvar Trail =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inheritsLoose(Trail, _React$PureComponent);\n\n  function Trail() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;\n    _this.first = true;\n    _this.instances = new Set();\n\n    _this.hook = function (instance, index, length, reverse) {\n      // Add instance to set\n      _this.instances.add(instance); // Return undefined on the first index and from then on the previous instance\n\n\n      if (reverse ? index === length - 1 : index === 0) return undefined;else return Array.from(_this.instances)[reverse ? index + 1 : index - 1];\n    };\n\n    return _this;\n  }\n\n  var _proto = Trail.prototype;\n\n  _proto.render = function render() {\n    var _this2 = this;\n\n    var _this$props = this.props,\n        items = _this$props.items,\n        _children = _this$props.children,\n        _this$props$from = _this$props.from,\n        from = _this$props$from === void 0 ? {} : _this$props$from,\n        initial = _this$props.initial,\n        reverse = _this$props.reverse,\n        keys = _this$props.keys,\n        delay = _this$props.delay,\n        onRest = _this$props.onRest,\n        props = _objectWithoutPropertiesLoose(_this$props, [\"items\", \"children\", \"from\", \"initial\", \"reverse\", \"keys\", \"delay\", \"onRest\"]);\n\n    var array = toArray(items);\n    return toArray(array).map(function (item, i) {\n      return React.createElement(Spring, _extends({\n        onRest: i === 0 ? onRest : null,\n        key: typeof keys === 'function' ? keys(item) : toArray(keys)[i],\n        from: _this2.first && initial !== void 0 ? initial || {} : from\n      }, props, {\n        delay: i === 0 && delay || undefined,\n        attach: function attach(instance) {\n          return _this2.hook(instance, i, array.length, reverse);\n        },\n        children: function children(props) {\n          var child = _children(item, i);\n\n          return child ? child(props) : null;\n        }\n      }));\n    });\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    this.first = false;\n    if (prevProps.items !== this.props.items) this.instances.clear();\n  };\n\n  return Trail;\n}(React.PureComponent);\n\nTrail.defaultProps = {\n  keys: function keys(item) {\n    return item;\n  }\n};\nvar DEFAULT = '__default';\n\nvar KeyframesImpl =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inheritsLoose(KeyframesImpl, _React$PureComponent);\n\n  function KeyframesImpl() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;\n    _this.guid = 0;\n    _this.state = {\n      props: {},\n      resolve: function resolve() {\n        return null;\n      },\n      last: true,\n      index: 0\n    };\n\n    _this.next = function (props, last, index) {\n      if (last === void 0) {\n        last = true;\n      }\n\n      if (index === void 0) {\n        index = 0;\n      }\n\n      _this.running = true;\n      return new Promise(function (resolve) {\n        _this.mounted && _this.setState(function (state) {\n          return {\n            props: props,\n            resolve: resolve,\n            last: last,\n            index: index\n          };\n        }, function () {\n          return _this.running = false;\n        });\n      });\n    };\n\n    return _this;\n  }\n\n  var _proto = KeyframesImpl.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.mounted = true;\n    this.componentDidUpdate({});\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.mounted = false;\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(previous) {\n    var _this2 = this;\n\n    var _this$props = this.props,\n        states = _this$props.states,\n        f = _this$props.filter,\n        state = _this$props.state;\n\n    if (previous.state !== this.props.state || this.props.reset && !this.running || !shallowEqual(states[state], previous.states[previous.state])) {\n      if (states && state && states[state]) {\n        (function () {\n          var localId = ++_this2.guid;\n          var slots = states[state];\n\n          if (slots) {\n            if (Array.isArray(slots)) {\n              var q = Promise.resolve();\n\n              var _loop = function _loop(i) {\n                var index = i;\n                var slot = slots[index];\n                var last = index === slots.length - 1;\n                q = q.then(function () {\n                  return localId === _this2.guid && _this2.next(f(slot), last, index);\n                });\n              };\n\n              for (var i = 0; i < slots.length; i++) {\n                _loop(i);\n              }\n            } else if (typeof slots === 'function') {\n              var index = 0;\n              slots( // next\n              function (props, last) {\n                if (last === void 0) {\n                  last = false;\n                }\n\n                return localId === _this2.guid && _this2.next(f(props), last, index++);\n              }, // cancel\n              function () {\n                return requestFrame(function () {\n                  return _this2.instance && _this2.instance.stop();\n                });\n              }, // ownprops\n              _this2.props);\n            } else {\n              _this2.next(f(states[state]));\n            }\n          }\n        })();\n      }\n    }\n  };\n\n  _proto.render = function render() {\n    var _this3 = this;\n\n    var _this$state = this.state,\n        props = _this$state.props,\n        resolve = _this$state.resolve,\n        last = _this$state.last,\n        index = _this$state.index;\n    if (!props || Object.keys(props).length === 0) return null;\n\n    var _this$props2 = this.props,\n        state = _this$props2.state,\n        filter = _this$props2.filter,\n        states = _this$props2.states,\n        config = _this$props2.config,\n        Component = _this$props2.primitive,\n        _onRest = _this$props2.onRest,\n        forwardRef = _this$props2.forwardRef,\n        rest = _objectWithoutPropertiesLoose(_this$props2, [\"state\", \"filter\", \"states\", \"config\", \"primitive\", \"onRest\", \"forwardRef\"]); // Arrayed configs need an index to process\n\n\n    if (Array.isArray(config)) config = config[index];\n    return React.createElement(Component, _extends({\n      ref: function ref(_ref) {\n        return _this3.instance = handleRef(_ref, forwardRef);\n      },\n      config: config\n    }, rest, props, {\n      onRest: function onRest(args) {\n        resolve(args);\n        if (_onRest && last) _onRest(args);\n      }\n    }));\n  };\n\n  return KeyframesImpl;\n}(React.PureComponent);\n\nKeyframesImpl.defaultProps = {\n  state: DEFAULT\n};\nvar Keyframes = React.forwardRef(function (props, ref) {\n  return React.createElement(KeyframesImpl, _extends({}, props, {\n    forwardRef: ref\n  }));\n});\n\nKeyframes.create = function (primitive) {\n  return function (states, filter) {\n    var _states;\n\n    if (filter === void 0) {\n      filter = function filter(states) {\n        return states;\n      };\n    }\n\n    if (typeof states === 'function' || Array.isArray(states)) states = (_states = {}, _states[DEFAULT] = states, _states);\n    return function (props) {\n      return React.createElement(KeyframesImpl, _extends({\n        primitive: primitive,\n        states: states,\n        filter: filter\n      }, props));\n    };\n  };\n};\n\nKeyframes.Spring = function (states) {\n  return Keyframes.create(Spring)(states, interpolateTo);\n};\n\nKeyframes.Trail = function (states) {\n  return Keyframes.create(Trail)(states, interpolateTo);\n};\n\nvar guid = 0;\n\nvar get = function get(props) {\n  var items = props.items,\n      keys = props.keys,\n      rest = _objectWithoutPropertiesLoose(props, [\"items\", \"keys\"]);\n\n  items = toArray(items !== void 0 ? items : null);\n  keys = typeof keys === 'function' ? items.map(keys) : toArray(keys); // Make sure numeric keys are interpreted as Strings (5 !== \"5\")\n\n  return _extends({\n    items: items,\n    keys: keys.map(function (key) {\n      return String(key);\n    })\n  }, rest);\n};\n\nvar Transition =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inheritsLoose(Transition, _React$PureComponent);\n\n  var _proto = Transition.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.mounted = true;\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.mounted = false;\n  };\n\n  function Transition(prevProps) {\n    var _this;\n\n    _this = _React$PureComponent.call(this, prevProps) || this;\n\n    _this.destroyItem = function (item, key, state) {\n      return function (values) {\n        var _this$props = _this.props,\n            onRest = _this$props.onRest,\n            onDestroyed = _this$props.onDestroyed;\n\n        if (_this.mounted) {\n          onDestroyed && onDestroyed(item);\n\n          _this.setState(function (_ref) {\n            var deleted = _ref.deleted;\n            return {\n              deleted: deleted.filter(function (t) {\n                return t.key !== key;\n              })\n            };\n          });\n\n          onRest && onRest(item, state, values);\n        }\n      };\n    };\n\n    _this.state = {\n      first: true,\n      transitions: [],\n      current: {},\n      deleted: [],\n      prevProps: prevProps\n    };\n    return _this;\n  }\n\n  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(props, _ref2) {\n    var first = _ref2.first,\n        prevProps = _ref2.prevProps,\n        state = _objectWithoutPropertiesLoose(_ref2, [\"first\", \"prevProps\"]);\n\n    var _get = get(props),\n        items = _get.items,\n        keys = _get.keys,\n        initial = _get.initial,\n        from = _get.from,\n        enter = _get.enter,\n        leave = _get.leave,\n        update = _get.update,\n        _get$trail = _get.trail,\n        trail = _get$trail === void 0 ? 0 : _get$trail,\n        unique = _get.unique,\n        config = _get.config;\n\n    var _get2 = get(prevProps),\n        _keys = _get2.keys,\n        _items = _get2.items;\n\n    var current = _extends({}, state.current);\n\n    var deleted = [].concat(state.deleted); // Compare next keys with current keys\n\n    var currentKeys = Object.keys(current);\n    var currentSet = new Set(currentKeys);\n    var nextSet = new Set(keys);\n    var added = keys.filter(function (item) {\n      return !currentSet.has(item);\n    });\n    var removed = state.transitions.filter(function (item) {\n      return !item.destroyed && !nextSet.has(item.originalKey);\n    }).map(function (i) {\n      return i.originalKey;\n    });\n    var updated = keys.filter(function (item) {\n      return currentSet.has(item);\n    });\n    var delay = 0;\n    added.forEach(function (key) {\n      // In unique mode, remove fading out transitions if their key comes in again\n      if (unique && deleted.find(function (d) {\n        return d.originalKey === key;\n      })) deleted = deleted.filter(function (t) {\n        return t.originalKey !== key;\n      });\n      var keyIndex = keys.indexOf(key);\n      var item = items[keyIndex];\n      var state = 'enter';\n      current[key] = {\n        state: state,\n        originalKey: key,\n        key: unique ? String(key) : guid++,\n        item: item,\n        trail: delay = delay + trail,\n        config: callProp(config, item, state),\n        from: callProp(first ? initial !== void 0 ? initial || {} : from : from, item),\n        to: callProp(enter, item)\n      };\n    });\n    removed.forEach(function (key) {\n      var keyIndex = _keys.indexOf(key);\n\n      var item = _items[keyIndex];\n      var state = 'leave';\n      deleted.push(_extends({}, current[key], {\n        state: state,\n        destroyed: true,\n        left: _keys[Math.max(0, keyIndex - 1)],\n        right: _keys[Math.min(_keys.length, keyIndex + 1)],\n        trail: delay = delay + trail,\n        config: callProp(config, item, state),\n        to: callProp(leave, item)\n      }));\n      delete current[key];\n    });\n    updated.forEach(function (key) {\n      var keyIndex = keys.indexOf(key);\n      var item = items[keyIndex];\n      var state = 'update';\n      current[key] = _extends({}, current[key], {\n        item: item,\n        state: state,\n        trail: delay = delay + trail,\n        config: callProp(config, item, state),\n        to: callProp(update, item)\n      });\n    }); // This tries to restore order for deleted items by finding their last known siblings\n\n    var out = keys.map(function (key) {\n      return current[key];\n    });\n    deleted.forEach(function (_ref3) {\n      var left = _ref3.left,\n          right = _ref3.right,\n          transition = _objectWithoutPropertiesLoose(_ref3, [\"left\", \"right\"]);\n\n      var pos; // Was it the element on the left, if yes, move there ...\n\n      if ((pos = out.findIndex(function (t) {\n        return t.originalKey === left;\n      })) !== -1) pos += 1; // Or how about the element on the right ...\n\n      if (pos === -1) pos = out.findIndex(function (t) {\n        return t.originalKey === right;\n      }); // Maybe we'll find it in the list of deleted items\n\n      if (pos === -1) pos = deleted.findIndex(function (t) {\n        return t.originalKey === left;\n      }); // Checking right side as well\n\n      if (pos === -1) pos = deleted.findIndex(function (t) {\n        return t.originalKey === right;\n      }); // And if nothing else helps, move it to the start \\_()_/\n\n      pos = Math.max(0, pos);\n      out = [].concat(out.slice(0, pos), [transition], out.slice(pos));\n    });\n    return {\n      first: first && added.length === 0,\n      transitions: out,\n      current: current,\n      deleted: deleted,\n      prevProps: props\n    };\n  };\n\n  _proto.render = function render() {\n    var _this2 = this;\n\n    var _this$props2 = this.props,\n        initial = _this$props2.initial,\n        _this$props2$from = _this$props2.from,\n        _this$props2$enter = _this$props2.enter,\n        _this$props2$leave = _this$props2.leave,\n        _this$props2$update = _this$props2.update,\n        onDestroyed = _this$props2.onDestroyed,\n        keys = _this$props2.keys,\n        items = _this$props2.items,\n        onFrame = _this$props2.onFrame,\n        onRest = _this$props2.onRest,\n        onStart = _this$props2.onStart,\n        trail = _this$props2.trail,\n        config = _this$props2.config,\n        _children = _this$props2.children,\n        unique = _this$props2.unique,\n        reset = _this$props2.reset,\n        extra = _objectWithoutPropertiesLoose(_this$props2, [\"initial\", \"from\", \"enter\", \"leave\", \"update\", \"onDestroyed\", \"keys\", \"items\", \"onFrame\", \"onRest\", \"onStart\", \"trail\", \"config\", \"children\", \"unique\", \"reset\"]);\n\n    return this.state.transitions.map(function (_ref4, i) {\n      var _ref5;\n\n      var state = _ref4.state,\n          key = _ref4.key,\n          item = _ref4.item,\n          from = _ref4.from,\n          to = _ref4.to,\n          trail = _ref4.trail,\n          config = _ref4.config,\n          destroyed = _ref4.destroyed;\n      return React.createElement(Keyframes, _extends({\n        reset: reset && state === 'enter',\n        primitive: Spring,\n        state: state,\n        filter: interpolateTo,\n        states: (_ref5 = {}, _ref5[state] = to, _ref5),\n        key: key,\n        onRest: destroyed ? _this2.destroyItem(item, key, state) : onRest && function (values) {\n          return onRest(item, state, values);\n        },\n        onStart: onStart && function () {\n          return onStart(item, state);\n        },\n        onFrame: onFrame && function (values) {\n          return onFrame(item, state, values);\n        },\n        delay: trail,\n        config: config\n      }, extra, {\n        from: from,\n        children: function children(props) {\n          var child = _children(item, state, i);\n\n          return child ? child(props) : null;\n        }\n      }));\n    });\n  };\n\n  return Transition;\n}(React.PureComponent);\n\nTransition.defaultProps = {\n  keys: function keys(item) {\n    return item;\n  },\n  unique: false,\n  reset: false\n}; // Solution: https://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly/658662\n\nvar stringShapeRegex = /[+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\n\nfunction createInterpolation(config$$1) {\n  var outputRange = config$$1.output;\n  var outputRanges = outputRange[0].match(stringShapeRegex).map(function () {\n    return [];\n  });\n  outputRange.forEach(function (value) {\n    value.match(stringShapeRegex).forEach(function (number, i) {\n      return outputRanges[i].push(+number);\n    });\n  });\n  var interpolations = outputRange[0].match(stringShapeRegex).map(function (_, i) {\n    return Interpolation.create(_extends({}, config$$1, {\n      output: outputRanges[i]\n    }));\n  });\n  return function (input) {\n    var i = 0;\n    return outputRange[0].replace(stringShapeRegex, function () {\n      return interpolations[i++](input);\n    });\n  };\n} // Render 30/fps by default\n\n\ninjectFrame(function (cb) {\n  return setTimeout(cb, 1000 / 30);\n}, function (r) {\n  return clearTimeout(r);\n});\ninjectInterpolation(createInterpolation);\ninjectApplyAnimatedValues(function () {\n  return false;\n}, function (style) {\n  return style;\n});\nexport { Spring, Keyframes, Transition, Trail, Controller, config, createAnimatedComponent as animated, interpolate$1 as interpolate, Globals };","map":null,"metadata":{},"sourceType":"module"}